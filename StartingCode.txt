#Requires -Version 2.0
###########################################
# Updated Date:	6 April 2016
# Purpose:		Provide a PowerShell GUI for _______ Process.
# Requirements: PS-CFW
###########################################

	$strProjName = "Project";
	$strVer = "0.1beta";
	$strLogLoc = "Logs_ITSS";
	$strLocalLoc = "Local";
	$arrIncludes = @("AD-Routines.ps1", "Common.ps1", "DB-Routines.ps1", "Display.ps1", "Exchange.ps1", "FileOperations.ps1", "Forms.ps1", "Jobs.ps1");

	$strCodeFile = $strProjName + ".ps1";
	$strGUIFile = $strProjName + "_GUI\MainWindow.xaml";
	$strLogFile = $strProjName + ".log";
	$strLogDirS = "";
	$strLogDirL = "C:\Users\ITSS-Tools\Logs\" + $strProjName + "\";
	$strLogDir = "";
	$Error.Clear();
	if ([String]::IsNullOrWhiteSpace($MyInvocation.MyCommand.Path)){
		$ScriptDir = (Get-Location).ToString();
	}else{
		$ScriptDir = Split-Path $MyInvocation.MyCommand.Path;
	}

	$strMessage = "Starting " + $strProjName + ", ver " + $strVer + ".  --  PS ver: " + $PSVersionTable.PSVersion.ToString() + " ($env:Processor_Architecture bit)  --  .NET ver: " + $PSVersionTable.CLRVersion.ToString() + ".";
	Write-Host $strMessage;

	#GetPathing(), VerifyPathing(), WriteLogFile(), and LoadRequired() are functions in Common.ps1, that are all used before Loading the Required Modules/Scripts.
	#It Must be defined before we can use it.
	. ($ScriptDir + "\..\PS-CFW\" + "Common.ps1")

	#Get pathing info.
	$strPathing = GetPathing $strLogLoc;
	if ($strPathing.Results -gt 0){
		#Share Path
		$strLogDirS = $strPathing.Returns.Rows[0].Path + $strProjName + "\";
	}
	$strPathing = GetPathing $strLocalLoc;
	if ($strPathing.Results -gt 0){
		#Local Path
		$strLogDirL = $strPathing.Returns.Rows[0].Path + "Logs\" + $strProjName + "\";
	}
	#Make sure the log directories exist.
	$strLogDir = VerifyPathing $strLogDirL $strLogDirS;

	WriteLogFile $strMessage $strLogDir $strLogFile;

	#Ensure .NET 4.x support is "turned on".
	if ($PSVersionTable.CLRVersion.Major -lt 4){
		$bResults = EnableDotNet4 $True $MyInvocation.MyCommand.Path;
		if ($bResults){
			$strCommand = "& '" + $MyInvocation.MyCommand.Path + "'";

			$strMessage = "The PowerShell config files for .NET 4.x support should have been created, so restarting.";
			WriteLogFile $strMessage $strLogDir $strLogFile;

			Write-Host $strMessage -foregroundcolor Green -background blue;
			Write-Host "Press any key to continue ..." -foregroundcolor red;
			$x = $host.UI.RawUI.ReadKey("NoEcho, IncludeKeyDown");

			Start-Process ($PSHOME + "\powershell.exe") -ArgumentList "-ExecutionPolicy ByPass -Command $strCommand";
			#Start-Process ($PSHOME + "\powershell.exe") -ArgumentList "-STA -ExecutionPolicy ByPass -Command $strCommand";
			exit;

			#http://powershell.com/cs/blogs/tobias/archive/2012/05/09/managing-child-processes.aspx
			$objProcess = (Get-WmiObject -Class Win32_Process -Filter "ParentProcessID=$PID").ProcessID;
			Stop-Process -Id $PID;
		}
	}

	#Load/Include $arrIncludes Scripts/Files/modules.
	$bResults = (. LoadRequired $arrIncludes $ScriptDir $strLogDir $strLogFile);
	if ($bResults -ne $True){
		$strMessage = "Failed to load all the required modules/scripts.  Aborting.";
		Write-Host $strMessage;
		WriteLogFile $strMessage $strLogDir $strLogFile;
		#MsgBox "Failed to load all the required modules/scripts.  Aborting." "Missing Required Files";

		Write-Host "Press any key to continue ...";
		$x = $host.UI.RawUI.ReadKey("NoEcho, IncludeKeyDown");

		return 1;
		exit;
	}

	#Commented out the following, as we are going to an xCopy update method, and checking ver #'s becomes obsolete.
	##$objRet = (. CheckVer "Includes" "");		#To make sure the Required/Included files are running latest ver.
	#$objRet = CheckVer $strProjName $strVer;
	#if (($objRet.Message -eq "Disable") -or ($objRet.Results -eq $False)){
	#	if (($strVer.EndsWith("b")) -or ($strVer.EndsWith("B")) -or ($strVer.EndsWith("beta")) -or ($strVer.EndsWith("Beta"))){
	#		$strMessage = $objRet.Returns[1];
	#	}
	#	else{
	#		$strMessage = $objRet.Returns[0];
	#	}
	#	$strMessage = "You do not appear to be running the latest version of $strProjName." + "`r`n" + "The latest version is $strMessage, and you are running ver $strVer.";
	#	Write-Host "`r`n$strMessage `r`n" -foregroundcolor red -background black;
	#	WriteLogFile $strMessage $strLogDir $strLogFile;

	#	Write-Host "Press any key to continue ...";
	#	$x = $host.UI.RawUI.ReadKey("NoEcho, IncludeKeyDown");
	#	exit;
	#}

	# ---=== Start Add project code functions here ===---
	function btnGetValidated_Click{
	  #Code for the Button Click event
	}

	function btnSubmit_Click{
		#Code for the Button Click event

	}
	# ---=== End Add project code functions here ===---

	# ---=== Start Code to do Just before show GUI. ===---
	$bolAsAdmin = $False;
	#If running as admin is irrelevant then comment out the next 26 lines.
	$strMessage = "Checking if running as Admin.";
	Write-Host $strMessage;
	WriteLogFile $strMessage $strLogDir $strLogFile;
	$bolAsAdmin = AsAdmin;
	$strResponse = "yes";
	if ($bolAsAdmin -ne $True){
		$strResponse = MsgBox "You should run this PS Script with admin permissions.`r`n`r`nWant us to restart this PS Script for you?" "Not running with Admin perms" 4;

		if ($strResponse -eq "yes"){
			$strCommand = "& '" + $MyInvocation.MyCommand.Path + "'";

			$strMessage = "Restarting as Admin.";
			WriteLogFile $strMessage $strLogDir $strLogFile;

			#method 1.  Uses Windows UAC to get creds.
			Start-Process ($PSHOME + "\powershell.exe") -verb runas -ArgumentList "-ExecutionPolicy ByPass -Command $strCommand";
			#Start-Process ($PSHOME + "\powershell.exe") -verb runas -ArgumentList "-STA -ExecutionPolicy ByPass -Command $strCommand";
			exit;

			#http://powershell.com/cs/blogs/tobias/archive/2012/05/09/managing-child-processes.aspx
			$objProcess = (Get-WmiObject -Class Win32_Process -Filter "ParentProcessID=$PID").ProcessID;
			Stop-Process -Id $PID;
		}else{
			$bolAsAdmin = $True;
		}
	}

	#Change the next lines $True/$False depending on the desired action for running as Admin.
	if ($bolAsAdmin -eq $True){
		$strMessage = "You should not run this as Admin.";
		WriteLogFile $strMessage $strLogDir $strLogFile;
	}
	else{
		if ((Test-Path -Path ($ScriptDir + "\" + $strGUIFile))){
			#GUI File Exists
			$strMessage = "Starting Load of GUI.";
			Write-Host $strMessage;
			WriteLogFile $strMessage $strLogDir $strLogFile;

			#Hide the PowerShell Console.
			[ConsoleHelper]::HideConsole();
			$objTimer = $null;

			$objRet = GetXAMLGUI ($ScriptDir + "\" + $strGUIFile) ($ScriptDir + "\" + $strCodeFile);
			WriteLogFile ($objRet.Name) $strLogDir $strLogFile;
			if (($objRet.Message -Match "Failed to add") -or ($objRet.Message -Match "Error adding") -or ($objRet.Message -Match "Error")){
				#MsgBox $objRet.Message;
				$strMessage = "Problems reading xaml GUI --> " + ($objRet.Message);
				WriteLogFile $strMessage $strLogDir $strLogFile;
			}

			if ($objRet.Results -eq $True){
				$strMessage = "Loading XAML GUI.";
				Write-Host $strMessage;
				WriteLogFile $strMessage $strLogDir $strLogFile;

				Write-Host $objRet.Message;
				$strResult = $objRet.Returns.ShowDialog();
			}
			else{
				$strMessage = "Failed to load GUI." + "`r`n" + "'" + $ScriptDir + "\" + $strGUIFile + "'" + "`r`n`r`n" + $objRet.Message;
				Write-Host $strMessage;
				WriteLogFile $strMessage $strLogDir $strLogFile;
			}

		}
		else{
			$strMessage = "GUI Interface file not found." + "`r`n" + "(" + $ScriptDir + "\" + $strGUIFile + ")";
			WriteLogFile $strMessage $strLogDir $strLogFile;
			MsgBox $strMessage;
		}
	}
	# ---=== GUI has been shut down, or error trying to show it. ===---

	#Do clean up.
	[ConsoleHelper]::ShowConsole();				#To show the PowerShell Console.
