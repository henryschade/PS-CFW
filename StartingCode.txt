#Requires -Version 2.0
###########################################
# Updated Date:	9 December 2015
# Purpose:		Provide a PowerShell GUI for _______ Process.
# Requirements: PS-CFW
###########################################

	$strProjName = "Project";
	$strVer = "0.1beta";
	$strLogLoc = "Logs_ITSS";
	$strLocalLoc = "Local";
	$arrIncludes = @("AD-Routines.ps1", "Common.ps1", "DB-Routines.ps1", "Display.ps1", "Exchange.ps1", "FileOperations.ps1", "Forms.ps1", "Jobs.ps1");

	$strCodeFile = $strProjName + ".ps1";
	$strGUIFile = $strProjName + "_GUI\MainWindow.xaml";
	$strLogFile = $strProjName + ".log";
	$strLogDirS = "";
	$strLogDirL = "C:\ITSS-Tools\Logs\" + $strProjName + "\";
	$strLogDir = "";
	$ScriptDir = Split-Path $MyInvocation.MyCommand.Path;

	$strMessage = "Starting " + $strProjName + ", ver " + $strVer + ".  --  PS ver: " + $PSVersionTable.PSVersion.ToString() + " ($env:Processor_Architecture bit)  --  .NET ver: " + $PSVersionTable.CLRVersion.ToString() + ".";
	Write-Host $strMessage;

	#GetPathing(), WriteLogFile(), and LoadRequired() are functions in Common.ps1, that are all used before Loading the Required Modules/Scripts.
	#It Must be defined before we can use it.
	. ($ScriptDir + "\..\PS-CFW\" + "Common.ps1")

	#Get pathing info.
	$strPathing = GetPathing $strLogLoc;
	if ($strPathing.Results -gt 0){
		$strLogDirS = $strPathing.Returns.Rows[0].Path + $strProjName + "\";
	}
	$strPathing = GetPathing $strLocalLoc;
	if ($strPathing.Results -gt 0){
		$strLogDirL = $strPathing.Returns.Rows[0].Path + "Logs\" + $strProjName + "\";
	}
	#Make sure the log directories exist.
	if (!(Test-Path -Path $strLogDirL)){
		#Need to create the directory
		#PS mkdir, will create any parent folders needed.
		$strResults = mkdir $strLogDirL;
	}
	if ((!(Test-Path -Path $strLogDirS)) -and ($strLogDirS -ne "")){
		#Need to create the directory
		if ((Test-Path -Path ("\\" + $strLogDirS.Split("\")[2] + "\" + $strLogDirS.Split("\")[3]))){
			#PS mkdir, will create any parent folders needed.
			$strResults = mkdir $strLogDirS;
		}
	}
	#Set logging path
	if ((!(Test-Path -Path $strLogDirS)) -or ($strLogDirS -eq "")){
		$strLogDir = $strLogDirL;
	}
	else{
		$strLogDir = $strLogDirS;
	}

	WriteLogFile $strMessage $strLogDir $strLogFile;

	#Load/Include $arrIncludes Scripts/Files/modules.
	#foreach ($strInclude in $arrIncludes){
	#	$Error.Clear();
	#	if (Test-Path -Path ($ScriptDir + "\..\PS-CFW\" + $strInclude)){
	#		. ($ScriptDir + "\..\PS-CFW\" + $strInclude)
	#	}
	#	else{
	#		. ($ScriptDir + "\" + $strInclude)
	#	}
	#	if ($Error){WriteLogFile "------- Error 'loading' '$strInclude.ps1'.`r`n$Error" $strLogDir $strLogFile; $Error.Clear();}
	#}
	$bResults = (. LoadRequired $arrIncludes $ScriptDir $strLogDir $strLogFile);
	if ($bResults -ne $True){
		$strMessage = "Failed to load all the required modules/scripts.  Aborting.";
		Write-Host $strMessage;
		WriteLogFile $strMessage $strLogDir $strLogFile;
		#MsgBox "Failed to load all the required modules/scripts.  Aborting." "Missing Required Files";
		return 1;
	}

	$objRet = CheckVer $strProjName $strVer $strLogDir $strLogFile;

	#Ensure .NET 4.x support is "turned on".
	if ($PSVersionTable.CLRVersion.Major -lt 4){
		$bResults = EnableDotNet4;
		if ($bResults){
			$strCommand = "& '" + $MyInvocation.MyCommand.Path + "'";

			$strMessage = "The PowerShell config files for .NET 4.x support should have been created, so restarting.";
			WriteLogFile $strMessage $strLogDir $strLogFile;

			Write-Host $strMessage -foregroundcolor Green -background blue;
			Write-Host "Press any key to continue ..." -foregroundcolor red;
			$x = $host.UI.RawUI.ReadKey("NoEcho, IncludeKeyDown");

			Start-Process ($PSHOME + "\powershell.exe") -ArgumentList "-ExecutionPolicy ByPass -Command $strCommand";
			#Start-Process ($PSHOME + "\powershell.exe") -ArgumentList "-STA -ExecutionPolicy ByPass -Command $strCommand";
			exit;

			#http://powershell.com/cs/blogs/tobias/archive/2012/05/09/managing-child-processes.aspx
			$objProcess = (Get-WmiObject -Class Win32_Process -Filter "ParentProcessID=$PID").ProcessID;
			Stop-Process -Id $PID;
		}
	}

	# ---=== Start Add project code functions here ===---
	function btnGetValidated_Click{
	  #Code for the Button Click event
	}

	function btnSubmit_Click{
		#Code for the Button Click event

	}
	# ---=== End Add project code functions here ===---

	# ---=== Start Code to do Just before show GUI. ===---
	$bolAsAdmin = $False;
	#If running as admin is irrelevant then comment out the next 26 lines.
	$strMessage = "Checking if running as Admin.";
	Write-Host $strMessage;
	WriteLogFile $strMessage $strLogDir $strLogFile;
	$bolAsAdmin = AsAdmin;
	$strResponse = "yes";
	if ($bolAsAdmin -ne $True){
		$strResponse = MsgBox "You should run this PS Script with admin permissions.`r`n`r`nWant us to restart this PS Script for you?" "Not running with Admin perms" 4;

		if ($strResponse -eq "yes"){
			$strCommand = "& '" + $MyInvocation.MyCommand.Path + "'";

			$strMessage = "Restarting as Admin.";
			WriteLogFile $strMessage $strLogDir $strLogFile;

			#method 1.  Uses Windows UAC to get creds.
			Start-Process ($PSHOME + "\powershell.exe") -verb runas -ArgumentList "-ExecutionPolicy ByPass -Command $strCommand";
			#Start-Process ($PSHOME + "\powershell.exe") -verb runas -ArgumentList "-STA -ExecutionPolicy ByPass -Command $strCommand";
			exit;

			#http://powershell.com/cs/blogs/tobias/archive/2012/05/09/managing-child-processes.aspx
			$objProcess = (Get-WmiObject -Class Win32_Process -Filter "ParentProcessID=$PID").ProcessID;
			Stop-Process -Id $PID;
		}else{
			$bolAsAdmin = $True;
		}
	}

	#Change the next lines $True/$False depending on the desired action for running as Admin.
	if ($bolAsAdmin -eq $True){
		$strMessage = "You should not run this as Admin.";
		WriteLogFile $strMessage $strLogDir $strLogFile;
	}
	else{
		if ((Test-Path -Path ($ScriptDir + "\" + $strGUIFile))){
			#GUI File Exists
			$strMessage = "Starting Load of GUI.";
			Write-Host $strMessage;
			WriteLogFile $strMessage $strLogDir $strLogFile;

			#Hide the PowerShell Console.
			[ConsoleHelper]::HideConsole();
			$objTimer = $null;

			$objRet = GetXAMLGUI ($ScriptDir + "\" + $strGUIFile) ($ScriptDir + "\" + $strCodeFile);
			WriteLogFile ($objRet.Name) $strLogDir $strLogFile;
			if (($objRet.Message -Match "Failed to add") -or ($objRet.Message -Match "Error adding") -or ($objRet.Message -Match "Error")){
				#MsgBox $objRet.Message;
				$strMessage = "Problems reading xaml GUI --> " + ($objRet.Message);
				WriteLogFile $strMessage $strLogDir $strLogFile;
			}

			if ($objRet.Results -eq $True){
				$strMessage = "Loading XAML GUI.";
				Write-Host $strMessage;
				WriteLogFile $strMessage $strLogDir $strLogFile;

				Write-Host $objRet.Message;
				$strResult = $objRet.Returns.ShowDialog();
			}
			else{
				$strMessage = "Failed to load GUI." + "`r`n" + "'" + $ScriptDir + "\" + $strGUIFile + "'" + "`r`n`r`n" + $objRet.Message;
				Write-Host $strMessage;
				WriteLogFile $strMessage $strLogDir $strLogFile;
			}

		}
		else{
			$strMessage = "GUI Interface file not found." + "`r`n" + "(" + $ScriptDir + "\" + $strGUIFile + ")";
			WriteLogFile $strMessage $strLogDir $strLogFile;
			MsgBox $strMessage;
		}
	}
	# ---=== GUI has been shut down, or error trying to show it. ===---

	#Do clean up.
	[ConsoleHelper]::ShowConsole();				#To show the PowerShell Console.
